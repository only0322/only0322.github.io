<!DOCTYPE html>
<html lang="en" >

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta property="og:title" content="MySQL实战45讲" />
<meta property="og:description" content="基础架构 先看MySQL的架构图
大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。
Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://only0322.github.io/post/geek/mysql/" />
<meta property="article:published_time" content="2021-01-27T10:36:34+08:00" />
<meta property="article:modified_time" content="2021-01-27T10:36:34+08:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL实战45讲"/>
<meta name="twitter:description" content="基础架构 先看MySQL的架构图
大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。
Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。"/>
<meta name="generator" content="Hugo 0.80.0" />


    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL实战45讲",
  "url": "https://only0322.github.io/post/geek/mysql/",
  "wordCount": "1195",
  "datePublished": "2021-01-27T10:36:34+08:00",
  "dateModified": "2021-01-27T10:36:34+08:00",
  "author": {
    "@type": "Person",
    "name": "吉法师"
  }
}
</script>



    <link rel="canonical" href="https://only0322.github.io/post/geek/mysql/">

    <title>MySQL实战45讲 | 吉法师的博客</title>

    
    <!-- combined, minified CSS -->
    
    <link href="https://only0322.github.io/css/style.beb8012edc08ba10be012f079d618dc243812267efe62e11f22fe49618f976a4.css" rel="stylesheet" integrity="sha256-vrgBLtwIuhC&#43;AS8HnWGNwkOBImfv5i4R8i/klhj5dqQ=" crossorigin="anonymous">
    

    <!-- minified Font Awesome for SVG icons -->
    
    <script defer src="https://only0322.github.io/js/fontawesome.min.ffbfea088a9a1666ec65c3a8cb4906e2a0e4f92dc70dbbf400a125ad2422123a.js" integrity="sha256-/7/qCIqaFmbsZcOoy0kG4qDk&#43;S3HDbv0AKElrSQiEjo=" crossorigin="anonymous"></script>

    <!-- RSS 2.0 feed -->
    

    

  </head>

  <body>

    
    <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link " href="https://only0322.github.io/">Home</a>
          
          <a class="nav-link" href="/cpp" title="">C/C&#43;&#43;学习归档</a>
          
          
          <a class="nav-link" href="/linux" title="">macOS&amp;Linux学习</a>
          
          
          <a class="nav-link" href="/nodejs" title="">Node.js学习</a>
          
          
          <a class="nav-link" href="/qt" title="">Qt学习归档</a>
          
          
          <a class="nav-link" href="/other" title="">其他语言</a>
          
          
          <a class="nav-link" href="/front" title="">前端知识汇总</a>
          
          
          <a class="nav-link" href="/opensource" title="">开源项目学习</a>
          
          
          <a class="nav-link" href="/shuju" title="">数据结构&amp;算法</a>
          
          
          <a class="nav-link" href="/allin" title="">编程知识大杂烩</a>
          
          
          <a class="nav-link" href="/netdb" title="">网络和数据库</a>
          
        </nav>
      </div>
    </div>
    

    
    
    <header class="blog-header">
      <div class="container">
        <h1 class="blog-title" dir="auto"><a href="https://only0322.github.io/" rel="home">吉法师的博客</a></h1>
        <p class="lead blog-description" dir="auto">爱一个人就应该勇敢地追求，哪怕是粉身碎骨，也比到老了后悔要好得多。</p>
      </div>
    </header>
    
    

    
    <div class="container">
      <div class="row">
        <div class="col-sm-8 blog-main">

          


<article class="blog-post">
  <header>
    <h2 class="blog-post-title" dir="auto"><a href="https://only0322.github.io/post/geek/mysql/">MySQL实战45讲</a></h2>
    <p class="blog-post-meta">
<time datetime="2021-01-27T10:36:34+08:00">Wed Jan 27, 2021</time>
</p>
  </header>
  <h2 id="基础架构">基础架构</h2>
<p>先看MySQL的架构图</p>
<p><img src="/images/geek/mysql/MySQL%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="架构图"></p>
<p>大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。</p>
<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。</p>
<p>其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<p><strong>MySQL的用户建立连接后，如果修改了权限，也得下次重新连接才会更新了。</strong></p>
<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。（基于tcp的）</p>
<p>长连接会占用内存，直到连接断掉才会释放，所以累积下来的话内存占用会很大。</p>
<h3 id="1sql查询语句执行过程">1.SQL查询语句执行过程</h3>
<p>连接创建过程见上。</p>
<p>MySQL的查询缓存会非常消耗性能，而且表更新之后就得刷新，所以8.0版本之后将整块功能都删除了。</p>
<h4 id="分析器和优化器">分析器和优化器</h4>
<p>SQL解析器，词法分析。</p>
<p>优化器会从SQL的解析结果，判断有多个索引先用哪个索引，逻辑相同的SQL条件会选择最快的执行方式。</p>
<h4 id="执行器">执行器</h4>
<p>会判断对某个表是否有查询权限，有权限就打开表执行，根据引擎定义去使用接口。</p>
<blockquote>
<p>有些时候，SQL语句要操作的表不只是SQL字面上那些。比如如果有个触发器，得在执行器阶段（过程中）才能确定。优化器阶段前是无能为力的</p>
</blockquote>
<p>如果表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<blockquote>
<p>1.调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p>
</blockquote>
<blockquote>
<p>2.调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p>
</blockquote>
<blockquote>
<p>3.执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
</blockquote>
<h3 id="2更新sql语句的执行过程">2.更新SQL语句的执行过程</h3>
<p>与查询不同的是，更新还涉及两个模块，redo log（重做日志），binlog（归档日志）。</p>
<h4 id="redo-log">redo log</h4>
<p>MySQL有用到WAL技术，Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。</p>
<p><img src="/images/geek/mysql/redolog.png" alt="redolog示意图"></p>
<p>数据写满之后，MySQL就会整体将切入点推进以下，擦掉已经写库的记录。</p>
<h4 id="binlog-日志模块">binlog 日志模块</h4>
<p>这两种日志有以下三点不同。</p>
<blockquote>
<p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
</blockquote>
<blockquote>
<p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p>
</blockquote>
<blockquote>
<p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
</blockquote>
<p><img src="/images/geek/mysql/update%E8%AF%AD%E5%8F%A5%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="update"></p>
<p>将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是&quot;两阶段提交&quot;。</p>
<h4 id="两阶段提交">两阶段提交</h4>
<blockquote>
<p>定义：redo log 等待 binlog 写入完成后，由 prepare 变为 commit 提交状态</p>
</blockquote>
<p><img src="/images/geek/mysql/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png" alt="两阶段提交"></p>
<p>先看数据的恢复过程：</p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p>
<p>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</p>
<p>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p>
<blockquote>
<p>redo log和binlog是两个独立的逻辑，如果不用两阶段提交，会出现数据库的状态和日志恢复出来的库状态不一致。</p>
</blockquote>
<pre><code class="language-word" data-lang="word">两个阶段的执行

1.请求阶段（commit-request phase，或称表决阶段，voting phase）
在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。
在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。

2.提交阶段（commit phase）
在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。
当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。
参与者在接收到协调者发来的消息后将执行响应的操作。

</code></pre><h4 id="崩溃恢复时的判断规则">崩溃恢复时的判断规则</h4>
<p>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</p>
<p>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：</p>
<p>a. 如果是，则提交事务；b. 否则，回滚事务。</p>
<h3 id="3事务和隔离级别">3.事务和隔离级别</h3>
<p>四种隔离级别：读未提交、读已提交、重复读、串行。</p>
<p><img src="/images/geek/mysql/%E4%BA%8B%E5%8A%A1.png" alt="事务"></p>
<p><strong>我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。</strong></p>
<blockquote>
<p>若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</p>
</blockquote>
<blockquote>
<p>若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</p>
</blockquote>
<blockquote>
<p>若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</p>
</blockquote>
<blockquote>
<p>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</p>
</blockquote>
<p>实现上，数据库会创建一个视图，访问的时候以视图的逻辑为准。</p>
<p>事务执行会生成多个视图，在隔离级别高的时候，要读到之前的事务数据，就必须通过回滚来得到。</p>
<p>当没有事务需要回滚日志的时候，回滚日志会被删除，当系统没有比这个回滚日志更早的视图，就说明可以删除了。</p>
<h4 id="尽量不使用长事务">尽量不使用长事务</h4>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p>
<p>曾有数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。</p>
<p>set autocommit=0 的命令会导致事务不自动提交，最后就有可能执行了一个长事务。</p>
<p><strong>查询执行时间超过60s的事务</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">
<span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> information_schema.innodb_trx <span style="color:#66d9ef">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">60</span>
</code></pre></div><h3 id="4索引">4.索引</h3>
<p>对于数据库的表而言，索引就相当于目录。</p>
<p>常见的索引数据结构：哈希表，有序数组，搜索树。</p>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。</p>
<h4 id="哈希表">哈希表</h4>
<p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。</p>
<p>哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
<p>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p><img src="/images/geek/mysql/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表"></p>
<p>哈希表只适合等值查询。</p>
<h4 id="有序数组">有序数组</h4>
<p>只适合静态存储引擎，比如存储某年某个城市的所有人口信息，这类不会被修改的数据。</p>
<p>身份证号递增排序，二分查找可以很快的查到某个人的信息。</p>
<p>但有序数组完全不适合插入和删除操作，所以最好只用于静态存储引擎。</p>
<h4 id="二叉搜索树">二叉搜索树</h4>
<p>保持树枝节点的左子树都比节点小，右子树都比节点大，某种程度的二分查找。但维护平衡的时候会比较耗时。</p>
<p>为什么数据库存储使用b+树 而不是二叉树，因为二叉树树高过高，每次查询都需要访问过多节点，即访问数据块过多，而从磁盘随机读取数据块过于耗时。</p>
<p>数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p>
<h4 id="回表">回表</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">
mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> T (
ID int <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>,
k int <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#ae81ff">0</span>, 
s varchar(<span style="color:#ae81ff">16</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#e6db74">&#39;&#39;</span>,
<span style="color:#66d9ef">index</span> k(k))
engine<span style="color:#f92672">=</span>InnoDB;

<span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> T <span style="color:#66d9ef">values</span>(<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;aa&#39;</span>),(<span style="color:#ae81ff">200</span>,<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;bb&#39;</span>),(<span style="color:#ae81ff">300</span>,<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#39;cc&#39;</span>),(<span style="color:#ae81ff">500</span>,<span style="color:#ae81ff">5</span>,<span style="color:#e6db74">&#39;ee&#39;</span>),(<span style="color:#ae81ff">600</span>,<span style="color:#ae81ff">6</span>,<span style="color:#e6db74">&#39;ff&#39;</span>),(<span style="color:#ae81ff">700</span>,<span style="color:#ae81ff">7</span>,<span style="color:#e6db74">&#39;gg&#39;</span>);
</code></pre></div><p><code>select * from T where k between 3 and 5</code></p>
<p>一起来看看这条 SQL 查询语句的执行流程：</p>
<ol>
<li>
<p>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</p>
</li>
<li>
<p>再到 ID 索引树查到 ID=300 对应的 R3；</p>
</li>
<li>
<p>在 k 索引树取下一个值 k=5，取得 ID=500；</p>
</li>
<li>
<p>再回到 ID 索引树查到 ID=500 对应的 R4；</p>
</li>
<li>
<p>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</p>
</li>
</ol>
<p>在这个过程中，回到主键索引树搜索的过程，我们称为回表。回表也就是值不在索引树上面，需要从表里进行查询。</p>
<h4 id="最左前缀原则">最左前缀原则</h4>
<p>索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是&quot;where name like ‘张 %’&quot;。</p>
<p>这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p>
<h4 id="索引下推">索引下推</h4>
<p>索引下推（Index Condition Pushdown），简称 ICP。 是Mysql 5.6版本引入的技术优化。</p>
<p>旨在 在“仅能利用最左前缀索的场景”下（而不是能利用全部联合索引），对不在最左前缀索引中的其他联合索引字段加以利用——在遍历索引时，就用这些其他字段进行过滤(where条件里的匹配)。</p>
<p>过滤会减少遍历索引查出的主键条数，从而减少回表次数，提示整体性能。</p>
<h3 id="5锁">5.锁</h3>
<p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p>
<h4 id="全局锁">全局锁</h4>
<p>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。</p>
<h4 id="表级锁">表级锁</h4>
<p>MySQL里面的表级锁共两种，表锁和元数据锁。</p>
<p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。
、
同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
<p><strong>元数据锁</strong></p>
<p>在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；</p>
<p>当要对表做结构变更操作的时候，加 MDL 写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p>
<p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。</p>
<p>因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
<p><img src="/images/geek/mysql/%E5%8A%A0%E5%AD%97%E6%AE%B5%E6%AD%BB%E9%94%81.png" alt="死锁"></p>
<blockquote>
<p>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。</p>
</blockquote>
<blockquote>
<p>由于 session B 需要的也是 MDL 读锁，因此可以正常执行。</p>
</blockquote>
<blockquote>
<p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p>
</blockquote>
<blockquote>
<p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。</p>
</blockquote>
<blockquote>
<p>前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
</blockquote>
<blockquote>
<p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p>
</blockquote>
<blockquote>
<p>你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
</blockquote>
<h4 id="二阶段锁">二阶段锁</h4>
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
<h4 id="死锁">死锁</h4>
<p>死锁简单来说就是两个事务在等待对方释放锁，造成了死锁。</p>
<p>死锁解决策略：</p>
<ol>
<li>直接等待，直到超时。</li>
</ol>
<p>缺点在于无法准确地估算等待时间，太长的话业务系统可能是无法接受的缓慢，短的话可能会造成误伤。</p>
<ol start="2">
<li>死锁检测。</li>
</ol>
<p>发现死锁，主动回滚死锁链条的某一个事务，让其他事务得以继续进行。</p>
<p>所有事务都要更新同一行的场景呢：</p>
<blockquote>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。</p>
</blockquote>
<blockquote>
<p>假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。</p>
</blockquote>
<blockquote>
<p>虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。</p>
</blockquote>
<blockquote>
<p>因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p>
</blockquote>
<p>这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；</p>
<p>如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。</p>
<p>基本思路就是，对于相同行的更新，在进入引擎之前排队。</p>
<p>这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p>
<pre><code>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。

还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。

这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。

</code></pre><h2 id="实战问题">实战问题</h2>
<h3 id="1普通索引和唯一索引选择">1.普通索引和唯一索引选择</h3>
<h4 id="查询">查询</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> name <span style="color:#66d9ef">from</span> CUser <span style="color:#66d9ef">where</span> id_card <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;xxxxxxxyyyyyyzzzzz&#39;</span>;
</code></pre></div><p>先看区别：</p>
<blockquote>
<p>对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的</p>
</blockquote>
<blockquote>
<p>记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p>
</blockquote>
<p>性能差距其实是微乎其微的：</p>
<p>InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p>在 InnoDB 中，每个数据页的大小默认是 16KB。</p>
<p>MySQL将数据一次性加载进了内存，所以查询起来的速度也很快了。</p>
<h4 id="更新">更新</h4>
<p>InnoDB更新有一个change buffer，不会直接写盘，会先存放在内存中。</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。</p>
<p>在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p>
<hr>
<p>如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。</p>
<p>第一种情况是，这个记录要更新的目标页在内存中。</p>
<p>这时，InnoDB 的处理流程如下：</p>
<p>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</p>
<p>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</p>
<p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p>
<p>但，这不是我们关注的重点。</p>
<p>第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下：</p>
<p>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</p>
<p>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</p>
<p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。</p>
<p>change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<hr>
<p>如果业务模型是插入后立刻查询，就会立即出发merge操作，影响性能了。</p>
<h4 id="索引选择和实践">索引选择和实践</h4>
<p>普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。</p>
<p>所以，建议尽量选择普通索引。如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。</p>
<p>而在其他情况下，change buffer 都能提升更新性能。</p>
<p>在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。</p>
<h3 id="2mysql选错索引">2.MySQL选错索引</h3>
<p>具体原因：MySQL的一张表支持多个索引，可能由于MySQL选错索引，导致执行速度很慢。</p>
<h4 id="优化器的逻辑">优化器的逻辑</h4>
<p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。</p>
<p>扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p>
<p>扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p>
<h4 id="判断扫描的行数">判断扫描的行数</h4>
<p>这是因为，如果使用索引 a，每次从索引 a 上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。</p>
<p>而如果选择扫描 10 万行，是直接在主键索引上扫描的，没有额外的代价。</p>
<p>优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。</p>
<p>当然，从执行时间看来，这个选择并不是最优的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t <span style="color:#66d9ef">where</span> (a <span style="color:#66d9ef">between</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">and</span> <span style="color:#ae81ff">1000</span>)  <span style="color:#66d9ef">and</span> (b <span style="color:#66d9ef">between</span> <span style="color:#ae81ff">50000</span> <span style="color:#66d9ef">and</span> <span style="color:#ae81ff">100000</span>) <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> b <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><p>索引a需要查询1000行，索引b则是50000行，显然是索引a更快，但是优化器可能会选择索引b。</p>
<p>这个时候用force index是一种处理方案，但必须指定索引的名字，如果名字改了也会出现问题。</p>
<p><strong>主要在于MySQL认为选了索引b可以避免排序，因为索引已经是有序的了</strong></p>
<h3 id="3给字符串字段加索引">3.给字符串字段加索引</h3>
<p>字符串支持前缀索引，用全字符串索引还是前缀索引，各有优劣。</p>
<p>前缀索引节省空间，但可能会增加额外的记录扫描次数，全字符颙会占空间。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> id,name,email <span style="color:#66d9ef">from</span> SUser <span style="color:#66d9ef">where</span> email<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;zhangssxyz@xxx.com&#39;</span>;
</code></pre></div><p>全字符索引肯定只要查一次，前缀索引也许也要好几次，但是有一定区分度的话，也可以减少查询次数，还能节省空间。</p>
<h3 id="4mysql抖动">4.MySQL抖动</h3>
<p>抖动是指性能出现波动，或者某些时间内数据库无法处理新的请求。</p>
<p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>
<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。</p>
<p>这时候只能把最久不使用的数据页从内存中淘汰掉：</p>
<p>如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>
<p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p>
<p>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</p>
<p>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</p>
<blockquote>
<p>InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。</p>
</blockquote>
<blockquote>
<p>所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。</p>
</blockquote>
<blockquote>
<p>要尽量避免这种情况，你就要合理地设置 innodb_io_capacity 的值，并且平时要多关注脏页比例，不要让它经常接近 75%。</p>
</blockquote>
<h3 id="5表数据删除-表文件大小不变">5.表数据删除 表文件大小不变</h3>
<p>表数据既可以存在共享表空间里，也可以是单独的文件。</p>
<p>这个行为是由参数 innodb_file_per_table 控制的：</p>
<p>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</p>
<p>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</p>
<p>从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。</p>
<p>将这个值设置为ON，这样单独存储一个文件，删除表的时候也能够将空间清理，放在共享表空间就无法轻松地清理了。</p>
<h4 id="数据删除流程">数据删除流程</h4>
<p>假设，我们要删掉 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。</p>
<p>如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p>
<p>如果删除了一个数据页的数据，那么整个数据页都可以复用了。</p>
<p><strong>插入也会</strong></p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<p>由于 page A 满了，再插入一个 ID 是 550 的数据时，就不得不再申请一个新的页面 page B 来保存数据了。页分裂完成后，page A 的末尾就留下了空洞（注意：实际上，可能不止 1 个记录的位置是空洞）。</p>
<p>可以通过重建表来达到去除空洞的目的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> A engine<span style="color:#f92672">=</span>InnoDB
</code></pre></div><h3 id="6count的效率问题">6.count(*)的效率问题</h3>
<p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</p>
<p>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p>
<h4 id="为什么innodb不维护一个行数的属性呢">为什么InnoDB不维护一个行数的属性呢？</h4>
<p>即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p>
<h4 id="各种count的区别">各种count的区别</h4>
<ol>
<li>count(主键id)</li>
</ol>
<p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。</p>
<p>server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
<ol start="2">
<li>count(1)</li>
</ol>
<p>InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<ol start="3">
<li>count(字段)</li>
</ol>
<p>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</p>
<p>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p>
<ol start="4">
<li>count(*)</li>
</ol>
<p>count(<em>) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>) 肯定不是 null，按行累加。</p>
<pre><code>按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)，所以我建议你，尽量使用 count(*)。
</code></pre><h3 id="7order-by-是怎么工作的">7.order by 是怎么工作的？</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> city,name,age <span style="color:#66d9ef">from</span> t <span style="color:#66d9ef">where</span> city<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;杭州&#39;</span> <span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> name <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">1000</span>  ;
</code></pre></div><p>Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。</p>
<p>通常情况下，这个语句执行流程如下所示 ：</p>
<ol>
<li>
<p>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</p>
</li>
<li>
<p>从索引 city 找到第一个满足 city=&lsquo;杭州’条件的主键 id，也就是图中的 ID_X；</p>
</li>
<li>
<p>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</p>
</li>
<li>
<p>从索引 city 取下一个记录的主键 id；</p>
</li>
<li>
<p>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</p>
</li>
<li>
<p>对 sort_buffer 中的数据按照字段 name 做快速排序；</p>
</li>
<li>
<p>按照排序结果取前 1000 行返回给客户端。</p>
</li>
</ol>
<p>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。否则就需要放在临时文件中排序。</p>
<p>sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p>
<h4 id="rowid排序">rowid排序</h4>
<p>max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。</p>
<p>它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p>
<p>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p>
<p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p>
<p>这也就体现了 MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。</p>
<p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p>
<p><strong>如果对排序的字段设置索引，就可以不需要再重新排序了</strong></p>
<h3 id="8如何显示随机消息">8.如何显示随机消息</h3>
<p>直接使用 order by rand()，这个语句需要 Using temporary 和 Using filesort，查询的执行代价往往是比较大的。所以，在设计的时候你要尽量避开这种写法。</p>
<p>可以考虑以下的方法</p>
<p>取得整个表的行数，记为 C；</p>
<p>根据相同的随机方法得到 Y1、Y2、Y3；</p>
<p>再执行三个 limit Y, 1 语句得到三行数据。</p>
<h3 id="9sql逻辑相同但是性能差异大">9.SQL逻辑相同但是性能差异大</h3>
<p>例如： 为什么条件是 where t_modified=&lsquo;2018-7-1’的时候可以用上索引，而改成 where month(t_modified)=7 的时候就不行了？</p>
<p>因为month函数有可能会破坏索引的有序性，MySQL会因此而不走索引。</p>
<p><strong>需要注意的是，优化器并不是要放弃使用这个索引。</strong></p>
<p>在这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_modified，优化器对比索引大小后发现，索引 t_modified 更小，遍历这个索引比遍历主键索引来得更快。因此最终还是会选择索引 t_modified。</p>
<p>不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索引。</p>
<p>比如，对于 select * from tradelog where id + 1 = 10000 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。</p>
<p>所以，需要你在写 SQL 语句的时候，手动改写成 where id = 10000 -1 才可以。</p>
<h3 id="10隐式类型转换">10.隐式类型转换</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> tradelog <span style="color:#66d9ef">where</span> tradeid<span style="color:#f92672">=</span><span style="color:#ae81ff">110717</span>;
</code></pre></div><p>字段是varchar ，然而输入的是数字的时候。</p>
<blockquote>
<p>现在这里就有两个问题：</p>
</blockquote>
<blockquote>
<p>数据类型转换的规则是什么？</p>
</blockquote>
<blockquote>
<p>为什么有数据类型转换，就需要走全索引扫描？</p>
</blockquote>
<p>因为在内部会有类型转换，本质上是调用了函数，<strong>对索引字段做函数操作，优化器会放弃走树搜索功能。</strong></p>
<p><strong>在 MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。</strong></p>
<p>还有编码转换 但比较少见。</p>
<h3 id="11查询变得很慢">11.查询变得很慢</h3>
<h4 id="1查询长时间不返回">1.查询长时间不返回</h4>
<h5 id="有可能是表被锁了">有可能是表被锁了。</h5>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">show</span> processlist
<span style="color:#66d9ef">select</span> blocking_pid <span style="color:#66d9ef">from</span> sys.schema_table_lock_waits
</code></pre></div><p>可以拿到id 然后kill。</p>
<h5 id="等flush">等flush</h5>
<p>MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">flush tables t <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">read</span> <span style="color:#66d9ef">lock</span>;

flush tables <span style="color:#66d9ef">with</span> <span style="color:#66d9ef">read</span> <span style="color:#66d9ef">lock</span>;
</code></pre></div><p>这两个 flush 语句，如果指定表 t 的话，代表的是只关闭表 t；如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p>
<p>所以，出现 Waiting for table flush 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。</p>
<p><strong>连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。</strong></p>
<h4 id="2查询慢">2.查询慢</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> t <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">c</span><span style="color:#f92672">=</span><span style="color:#ae81ff">50000</span> <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><p>比如这种需要扫描好多行的SQL语句。</p>
<p>带 lock in share mode 的 SQL 语句，是当前读，因此会直接读到 1000001 这个结果，所以速度很快；</p>
<p>而 select * from t where id=1 这个语句，是一致性读，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后，才将 1 这个结果返回。</p>
<h3 id="12幻读">12.幻读</h3>
<p>![幻读])(/images/geek/mysql/幻读.png)</p>
<ol>
<li>
<p>Q1 只返回 id=5 这一行；</p>
</li>
<li>
<p>在 T2 时刻，session B 把 id=0 这一行的 d 值改成了 5，因此 T3 时刻 Q2 查出来的是 id=0 和 id=5 这两行；</p>
</li>
<li>
<p>在 T4 时刻，session C 又插入一行（1,1,5），因此 T5 时刻 Q3 查出来的是 id=0、id=1 和 id=5 的这三行。</p>
</li>
</ol>
<p>关于幻读的说明：</p>
<ol>
<li>
<p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</p>
</li>
<li>
<p>上面 session B 的修改结果，被 session A 之后的 select 语句用“当前读”看到，不能称为幻读。幻读仅专指“新插入的行”。</p>
</li>
</ol>
<p>这样看，这些数据也没啥问题，但是我们再来看看这时候 binlog 里面的内容。</p>
<ol>
<li>
<p>T2 时刻，session B 事务提交，写入了两条语句；</p>
</li>
<li>
<p>T4 时刻，session C 事务提交，写入了两条语句；</p>
</li>
<li>
<p>T6 时刻，session A 事务提交，写入了 update t set d=100 where d=5 这条语句。</p>
</li>
</ol>
<p>可以看到，按照日志顺序执行，id=0 这一行的最终结果也是 (0,5,5)。</p>
<p>所以，id=0 这一行的问题解决了。</p>
<p>但同时你也可以看到，id=1 这一行，在数据库里面的结果是 (1,5,5)，而根据 binlog 的执行结果是 (1,5,100)，也就是说幻读的问题还是没有解决。为什么我们已经这么“凶残”地，把所有的记录都上了锁，还是阻止不了 id=1 这一行的插入和更新呢？</p>
<p>原因很简单。在 T3 时刻，我们给所有行加锁的时候，id=1 这一行还不存在，不存在也就加不上锁。</p>
<p>也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻读”会被单独拿出来解决的原因。</p>
<p><strong>新加入的记录，不是加锁能够解决的</strong></p>
<h5 id="如何解决幻读的问题">如何解决幻读的问题</h5>
<p>因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p>
<p>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。</p>
<p><strong>间隙锁和行锁合称 next-key lock</strong>，每个 next-key lock 是前开后闭区间。</p>
<p>也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p>
<ol>
<li>
<p>session A 执行 select … for update 语句，由于 id=9 这一行并不存在，因此会加上间隙锁 (5,10);</p>
</li>
<li>
<p>session B 执行 select … for update 语句，同样会加上间隙锁 (5,10)，间隙锁之间不会冲突，因此这个语句可以执行成功；</p>
</li>
<li>
<p>session B 试图插入一行 (9,9,9)，被 session A 的间隙锁挡住了，只好进入等待；</p>
</li>
<li>
<p>session A 试图插入一行 (9,9,9)，被 session B 的间隙锁挡住了。</p>
</li>
</ol>
<p>至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session A 的 insert 语句报错返回了。</p>
<p>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</p>


  

  
  <hr>
  <footer>

  
    <section>
    <h4>Share</h4>
    <nav class="nav sharing-icons">
      <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fonly0322.github.io%2fpost%2fgeek%2fmysql%2f" title="Share on Facebook"><span class="fab fa-facebook-f fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fonly0322.github.io%2fpost%2fgeek%2fmysql%2f" title="Share on LinkedIn"><span class="fab fa-linkedin-in fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://twitter.com/intent/tweet?url=https%3a%2f%2fonly0322.github.io%2fpost%2fgeek%2fmysql%2f&amp;text=MySQL%e5%ae%9e%e6%88%9845%e8%ae%b2" title="Tweet this"><span class="fab fa-twitter fa-2x"></span></a>
    </nav>
  </section>

  

  
  </footer>
  

</article> 



        </div> <!-- /.blog-main -->

        <aside class="col-sm-3 ml-auto blog-sidebar">
  
  <section class="sidebar-module sidebar-module-inset">
    <h4>About</h4>
    <p dir="auto">当我走在街上看到一颗奇怪的树，满脑子想的都是与你分享，我就知道我出大事了。</p>
  </section>
  

  
        <section class="sidebar-module">
    <h4>Recent Posts</h4>
    <ol class="list-unstyled">


<li><a href="/post/geek/mysql/">MySQL实战45讲</a></li>

<li><a href="/post/node/n-readlines/">n-readlines具体使用</a></li>

<li><a href="/post/java/base/">Java知识合集</a></li>

<li><a href="/post/geek/linux/">趣谈Linux操作系统学习笔记</a></li>

<li><a href="/post/geek/shuju/">数据结构与算法之美学习笔记</a></li>

<li><a href="/post/geek/netprotocol/">趣谈网络协议学习笔记</a></li>

<li><a href="/post/geek/geeklearn/">极客时间学习汇总</a></li>

<li><a href="/post/other/docker/">Docker技术详解</a></li>

<li><a href="/post/netdb/fenbushi/">分布式系统浅谈</a></li>

<li><a href="/post/netdb/net/">网络和网络协议部分</a></li>

    </ol>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  </section>

  

  
  <section class="sidebar-module">
    <h4>Links</h4>
    <ol class="list-unstyled">
      
      <li><a href="https://only0322.github.io/">QQ交流群609376922</a></li>
      
      <li><a href="https://gitee.com/onlyyyy_admin">码云主页</a></li>
      
    </ol>
  </section>
  
</aside>


      </div> <!-- /.row -->
    </div> <!-- /.container -->
    

    
    <footer class="blog-footer">
      <p dir="auto">
      
      Except where otherwise noted, content on this site is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution 4.0 International license</a>.
      
      </p>
      <p>
      <a href="#">Back to top</a>
      </p>
    </footer>
    

  </body>

</html>
