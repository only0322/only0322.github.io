<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>吉法师的博客</title>
    <link>https://only0322.github.io/</link>
    <description>Recent content on 吉法师的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Except where otherwise noted, content on this site is licensed under a [Creative Commons Attribution 4.0 International license](https://creativecommons.org/licenses/by-sa/4.0/).</copyright>
    <lastBuildDate>Thu, 13 Jan 2022 11:27:57 +0800</lastBuildDate><atom:link href="https://only0322.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Aop面向切面编程</title>
      <link>https://only0322.github.io/post/spring/aop%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 13 Jan 2022 11:27:57 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/spring/aop%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</guid>
      <description>AOP的产生 OOP：Object Oriented Programming，OOP作为面向对象编程的模式，获得了巨大的成功，OOP的主要功能是数据封装、继承和多态。
而AOP是一种新的编程方式，它和OOP不同，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，或者称之为切面（Aspect）。
也就是AOP能把需求做拆分，分为安全控制、日志、业务等模块，减少重复的实现和代码编写。
使用 一、装配AOP @Aspect @Component public class LoggingAspect { // 在执行UserService的每个方法前执行:  @Before(&amp;#34;execution(public * com.</description>
    </item>
    
    <item>
      <title>Spring Ioc容器解读</title>
      <link>https://only0322.github.io/post/spring/ioc%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 11 Jan 2022 10:52:29 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/spring/ioc%E5%AE%B9%E5%99%A8/</guid>
      <description>一、概述 什么是容器？ 容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。
通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。
Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。
二、Ioc原理 Ioc介绍 IoC全称Inversion of Control，直译为控制反转</description>
    </item>
    
    <item>
      <title>Electron打包简易教程</title>
      <link>https://only0322.github.io/post/front/electron%E6%89%93%E5%8C%85/</link>
      <pubDate>Fri, 07 Jan 2022 10:39:31 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/front/electron%E6%89%93%E5%8C%85/</guid>
      <description>一、工具选用 electron-packager 或electron-builder都可以，但个人还是更喜欢electron-packager
二、命令 electron-packager . Tal --platform=darwin --arch=x64 --icon=./Tal.ico --out=.</description>
    </item>
    
    <item>
      <title>Spring概述</title>
      <link>https://only0322.github.io/post/spring/spring%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 05 Jan 2022 16:20:55 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/spring/spring%E6%A6%82%E8%BF%B0/</guid>
      <description>一、介绍 Spring 是最受欢迎的企业级 Java 应用程序开发框架，数以百万的来自世界各地的开发人员使用 Spring 框架来创建性能好、易于测试、可重用的代码。
Spring 框架是一个开源的 Java 平台，它最初是由 Rod Johnson 编写的，并且于 2003 年 6 月首次在 Apache 2.</description>
    </item>
    
    <item>
      <title>Spring学习合集</title>
      <link>https://only0322.github.io/post/java/spring/</link>
      <pubDate>Wed, 05 Jan 2022 15:55:51 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/java/spring/</guid>
      <description> spring概述 Ioc容器 Aop面向切面编程  </description>
    </item>
    
    <item>
      <title>Java思维导图合集</title>
      <link>https://only0322.github.io/post/java/javaimage/</link>
      <pubDate>Wed, 05 Jan 2022 10:42:22 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/java/javaimage/</guid>
      <description> Java基础知识  Java面向对象  Java常用api  Java IO  Java 多线程、设计模式、网络、反射等  </description>
    </item>
    
    <item>
      <title>Jvm原理解析</title>
      <link>https://only0322.github.io/post/java/jvm/</link>
      <pubDate>Tue, 04 Jan 2022 18:40:40 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/java/jvm/</guid>
      <description>jvm知识导图
一、概述 JVM是Java虚拟机的简称，那Jvm到底做了什么事情呢？其实是实现了Java的一次编译，到处运行。
二、编译流程 java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行。
这样我们是不是可以推演，如果要在mac系统上运行，是不是只需要安装mac java虚拟机就行了。那么了解了这个基本原理后，我们尝试去做更深的研究，一个普通的java程序它的执行流程到底是怎样的呢？例如我们写了一段这样的代码：
public class HelloWorld { public static void main(String[] args) { System.</description>
    </item>
    
    <item>
      <title>Java HashMap知识归纳</title>
      <link>https://only0322.github.io/post/java/hashmap/</link>
      <pubDate>Tue, 04 Jan 2022 14:33:23 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/java/hashmap/</guid>
      <description>一、什么是HashMap HashMap是一个通过键值对存储数据的容器，所谓容器就是能够自动扩容的存储工具。我之前一直很好奇为什么叫Map，不是地图的意思吗？查了一下字典终于是明白了，这里的Map应该翻译成——映射。
二、原理 1.构造 HashMap构造的时候会有默认的初始容量16，以及扩展因子，默认是0.75。数据存储的比例达到扩展因子之后，HashMap就会扩充，增加大小是2倍，和C++的Vector类似。长度小于8的时候是链表，后面就会转为红黑树存储。
2.modCount 大概就是HashMap的结构信息，每次增加或者删除数据都会维护这个值。
3.fail-fast机制 在我们常见的java集合中就可能出现fail-fast机制,比如ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。
单线程在迭代的时候remove一个元素就会有fail-fast。</description>
    </item>
    
    <item>
      <title>Wrk使用浅谈</title>
      <link>https://only0322.github.io/post/other/wrk/</link>
      <pubDate>Tue, 21 Dec 2021 11:32:51 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/other/wrk/</guid>
      <description>介绍 Wrk是一款用C语言编写的轻量化压测软件，采用多路复用的方式进行压测，对机器的性能要求比Jmeter更低。
安装 git clone https://github.com/wg/wrk.git; cd /wrk; make; 命令 wrk -t5 -c100 -d 5s -s .</description>
    </item>
    
    <item>
      <title>《纯粹理性批判》总结</title>
      <link>https://only0322.github.io/post/book/critiquesummary/</link>
      <pubDate>Wed, 04 Aug 2021 11:52:33 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/book/critiquesummary/</guid>
      <description>一、来源 纯粹理性批判来自对休谟问题的回答，所以首先必须对休谟问题大致了解。
同笛卡尔一样，英国哲学家休谟也是一个走极端的人，这种品质成就了他在哲学上的重要地位。他把经验派的原则——凡在理智中的无不现在感觉中——推到了极点，从而终结了经验派。
休谟严格地按照经验派的原则去论证，从而剔除了思维中所有非感觉的成分。而这个成分就是：真理。因此他的结论是：人类不可能走上通往真理的道路上，并从中获取具有相对有效性的真理。
下面详细解释。比如我们做小球的碰撞实验，观察到的是这样一种事实，即小球甲运动到小球乙的位置，然后小球乙开始运动。我们测量甲乙的运动变化，根据变化列出方程，我们认为方程反应了甲乙运动的内在规律。但在得出规律之前，有一点必须被保证。 即，如何保证小球乙的运动是由小球甲导致的？如何能保证这两个事件之间具有因果关联？ 可能的事实是：甲乙的运动没有任何关系，小球甲运动到无限接近小球乙的地方就突然停下，然后小球乙就无缘无故自己开始运动。因为我们并没有看到甲和乙之间的能量传递。根据经验派的原则：没有感觉到的东西是不能被承认为真实的，所以不能把小球甲当做小球乙运动的原因。我们只能说，这两个事件之间没有任何因果联系。休谟认为，我们之所以把小球甲当作是小球乙运动的原因，只是出于一种心理习惯，即当我们在时间的序列中看到两个事件相继地发生，我们就会把这两个事件联系在一起并幻想其中有因果关系。
休谟问题的核心就是：不管实验设计得多精密，仅仅通过感知，是不可能找到真理的。因为感觉和规律，这两者完全异质，彻底隔绝。感觉是个别的，生灭的，个人有个人的感觉；而规律是普遍的，永恒的。不能保证从个别生灭的个体感觉上升到普遍永恒的规律。这就是休谟问题的核心。
二、纯粹理性批判——对知识与认识能力的反思 纯粹理性批判来自于康德对休谟问题的回应。这本书的整个理论框架充分反映出康德思想体系的基本特征：二元论、绝对的形式化。只要充分把握住纯粹理性批判的基本思路，就可以理解整个康德思想体系的核心。</description>
    </item>
    
    <item>
      <title>《纯粹理性批判》解析</title>
      <link>https://only0322.github.io/post/book/critique/</link>
      <pubDate>Fri, 11 Jun 2021 14:00:25 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/book/critique/</guid>
      <description>知乎对本书的解析
一、序 什么是形而上学？ 形而上学是指对世界本质的研究，即研究一切存在者，一切现象（尤其指抽象概念）的原因及本源。最早由亚里士多德所构建，称其为“第一哲学”、“第一科学”。
形而上学，是原始哲学的一个门类，指对在无法用经验证据证明的情况下，对世界本质的猜测。
13世纪起被作为哲学名词，用以指研究超经验的东西（灵魂、意志自由等）的学问。
矛盾冲突 理性试图向自身提出形而上学问题，而这些问题是理性无法回答的。因为当理性面向经验，将原理使用在经验中是没有问题的，因此理性就试图将其运用到更高的目标时，出现了问题。
 借助于这些原理，它（正如它的本性所将导致的那样）步步高升而达到更遥远的条件。但由于它发现，以这种方式它的工作必将永远停留在未完成状态，因为这些问题永远无法解决，这样，它就看到自己不得不求助于一些原理，这些原理超越一切可能的经验运用，却仍然显得是那么不容怀疑，以至于就连普遍的人类理性也对此表示同意。</description>
    </item>
    
    <item>
      <title>文学类归档</title>
      <link>https://only0322.github.io/book/</link>
      <pubDate>Fri, 11 Jun 2021 11:32:27 +0800</pubDate>
      
      <guid>https://only0322.github.io/book/</guid>
      <description> 纯粹理性批判解析 纯粹理性批判总结  </description>
    </item>
    
    <item>
      <title>深入浅出计算机组成原理</title>
      <link>https://only0322.github.io/post/geek/computertheory/</link>
      <pubDate>Wed, 26 May 2021 16:53:38 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/geek/computertheory/</guid>
      <description>入门 一、冯诺依曼体系结构 必备硬件：CPU、内存、主板、硬盘、输入输出设备，显卡。
可选硬件：独立显卡、机箱、风扇。
手机将CPU、内存、网络通信，乃至摄像头芯片，都封装到一个芯片，然后再嵌入到手机主板上。这种方式叫 SoC，也就是 System on a Chip（系统芯片）。</description>
    </item>
    
    <item>
      <title>初等数论学习</title>
      <link>https://only0322.github.io/post/math/numbertheory/</link>
      <pubDate>Wed, 21 Apr 2021 17:46:07 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/math/numbertheory/</guid>
      <description>一、整数 1.基础 1.1 良序性质 每个非空的正整数集合都有一个最小元
部分整数集合没有最小元，如小于100的整数，负整数，所有整数。
1.2 证明根号2是无理数 有理数都可以写成p/q的形式，其中p和q是整数
1.3 代数数和超越数 如果x是整系数多项式的根，则称为代数数，如根号2，和任何有理数。</description>
    </item>
    
    <item>
      <title>数学学习汇总</title>
      <link>https://only0322.github.io/math/</link>
      <pubDate>Wed, 21 Apr 2021 17:45:01 +0800</pubDate>
      
      <guid>https://only0322.github.io/math/</guid>
      <description> 初等数论  </description>
    </item>
    
    <item>
      <title>JavaScript核心原理解析</title>
      <link>https://only0322.github.io/post/geek/javascript/</link>
      <pubDate>Mon, 29 Mar 2021 17:57:06 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/geek/javascript/</guid>
      <description>一、JavaScript语言是如何构建起来的 1.delete 0：JavaScript到底有什么是可以销毁的 在 JavaScript 中表达式是一个很独特的东西，所有一切表达式运算的终极目的都是为了得到一个值，例如字符串。然后再用另外一些操作将这个值输出出来，例如变成网页中的一个元素（element）。
这个结果，才是delete这个操作要删除的东西。
在JS中，语句和表达式可以被执行并存在执行结果。
delete的运算结果   如果x根本不存在，delete x什么也不做，返回true</description>
    </item>
    
    <item>
      <title>Https协议与加密算法的运用</title>
      <link>https://only0322.github.io/post/netdb/https/</link>
      <pubDate>Sat, 27 Feb 2021 18:41:40 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/netdb/https/</guid>
      <description>一、什么是Https HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。</description>
    </item>
    
    <item>
      <title>MySQL实战45讲</title>
      <link>https://only0322.github.io/post/geek/mysql/</link>
      <pubDate>Wed, 27 Jan 2021 10:36:34 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/geek/mysql/</guid>
      <description>基础架构 先看MySQL的架构图
大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。
Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。而存储引擎层负责数据的存储和提取。</description>
    </item>
    
    <item>
      <title>n-readlines具体使用</title>
      <link>https://only0322.github.io/post/node/n-readlines/</link>
      <pubDate>Wed, 25 Nov 2020 15:44:45 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/node/n-readlines/</guid>
      <description>简介 n-readlines是我发现的一个按行读文件模块，使用起来也比readline简单。
示例 const lineByLine = require(&amp;#39;n-readlines&amp;#39;); const liner = new lineByLine(&amp;#39;.</description>
    </item>
    
    <item>
      <title>趣谈Linux操作系统学习笔记</title>
      <link>https://only0322.github.io/post/geek/linux/</link>
      <pubDate>Fri, 30 Oct 2020 10:38:09 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/geek/linux/</guid>
      <description>综述 1.命令配合grep组合使用 如：ps -ef | grep &amp;quot;zsh&amp;quot; 这样就可以找到名称中含有zsh的进程了。
系统初始化 1. 0号进程和1号进程 0号进程不会通过fork和kernel_thread生成 其实是一个进程管理的工具，通过kernel_thread来创建一号进程。</description>
    </item>
    
    <item>
      <title>数据结构与算法之美学习笔记</title>
      <link>https://only0322.github.io/post/geek/shuju/</link>
      <pubDate>Sat, 17 Oct 2020 23:00:04 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/geek/shuju/</guid>
      <description>一、入门 常见的时间复杂度类型 1.O(1) int i = 8; int j = 6; int sum = i + j; 代码的运行次数不会随着n进行变化，比如没有进入循环，所以是O(1)级别</description>
    </item>
    
    <item>
      <title>趣谈网络协议学习笔记</title>
      <link>https://only0322.github.io/post/geek/netprotocol/</link>
      <pubDate>Fri, 16 Oct 2020 21:09:41 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/geek/netprotocol/</guid>
      <description>一、通讯协议综述 1.有了IP地址为什么还需要Mac地址？ IP地址相当于是传送数据到某个位置，但不知道具体给哪台计算机，MAC地址就是为了解决这个问题。
至于修改MAC地址，实际上是修改了系统读取出来的这个MAC地址。也曾出现过两块劣质的网卡都是同一个MAC地址的情况，这样甚至会导致网络的堵塞。
mac是身份证，ip是地址。
用总经理和员工来比喻网络协议
不准确，因为开会的时候员工未必会给会议提出建议，而一次tcp的三次握手，每次握手ip和mac层都加入了自己的包头。
2.学习的方法 理解网络协议的工作模式，有两个小窍门：始终想象自己是一个处理网络包的程序：如何拿到网络包，如何根据规则进行处理，如何发出去；始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。
3.网段 私有IP地址是可以重复的，共有的则必须唯一。网段的划分是为了弥补刚开始对于计算机数量估计严重不足的问题。</description>
    </item>
    
    <item>
      <title>极客时间学习汇总</title>
      <link>https://only0322.github.io/post/geek/geeklearn/</link>
      <pubDate>Fri, 16 Oct 2020 21:08:42 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/geek/geeklearn/</guid>
      <description> 趣谈网络协议 数据结构与算法之美 趣谈Linux操作系统 MySQL实战45讲 JavaScript核心原理解析 深入浅出计算机组成原理  </description>
    </item>
    
    <item>
      <title>Docker技术详解</title>
      <link>https://only0322.github.io/post/other/docker/</link>
      <pubDate>Wed, 14 Oct 2020 23:02:15 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/other/docker/</guid>
      <description>1.docker介绍 Docker是诞生于2013年，是dotCloud的一个开源项目,基于Google推出的GO语言实现。遵从Apache2.0协议。
Docker的目标是实现轻量级的操作系统虚拟化的解决方案。
Docker的基础是Linux容器（LXC）等技术，（LXC系统提供工具来管理容器，具有先进的网络和存储支持，还有最小容器操作系统模版的广泛选择）。
在LXC的基础上Docker进行了进一步的封装，用户不需要去关心容器的管理，操作更简单。就像操作一个快速轻量的虚拟机一样简单。
2.docker使用 docker images 查看镜像
docker ps 查看容器</description>
    </item>
    
    <item>
      <title>分布式系统浅谈</title>
      <link>https://only0322.github.io/post/netdb/fenbushi/</link>
      <pubDate>Sat, 10 Oct 2020 16:49:26 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/netdb/fenbushi/</guid>
      <description>分布式的概念： 分布式这个词听起来很高大上, 实际上在我们以前经常构建分布式系统, 从最初的分离LAMP中的MySQL 到引入Varnish缓存页面, 再到使用LVS负载均衡Nginx|Apache, Nginx负载均衡Tomcat等等, 广义上都算是分布式系统.
简单来说分布式就是将一个系统的各个组件(MySQL、PHP、Apache …)分布在网络上的各台主机, 并且各组件之间仅通过消息传递来通信并协调工作。</description>
    </item>
    
    <item>
      <title>网络和网络协议部分</title>
      <link>https://only0322.github.io/post/netdb/net/</link>
      <pubDate>Sat, 03 Oct 2020 16:50:48 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/netdb/net/</guid>
      <description>一、OSI七层模型 开放式系统互联通信参考模型。
1.物理层（Physical Layer） 激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。
2.数据链路层（Data Link Layer） 数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能。
主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</description>
    </item>
    
    <item>
      <title>Http协议详解</title>
      <link>https://only0322.github.io/post/netdb/http/</link>
      <pubDate>Fri, 02 Oct 2020 10:51:07 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/netdb/http/</guid>
      <description>一、概述 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。
HTTP协议的主要特点可概括如下：
 1.支持客户/服务器模式。 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4.</description>
    </item>
    
    <item>
      <title>三次握手和四次挥手详解</title>
      <link>https://only0322.github.io/post/netdb/sanciwoshou/</link>
      <pubDate>Thu, 01 Oct 2020 09:32:09 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/netdb/sanciwoshou/</guid>
      <description>一、三次握手 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。
实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。
刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。
进行三次握手：</description>
    </item>
    
    <item>
      <title>网络和数据库知识汇总</title>
      <link>https://only0322.github.io/netdb/</link>
      <pubDate>Thu, 01 Oct 2020 09:26:51 +0800</pubDate>
      
      <guid>https://only0322.github.io/netdb/</guid>
      <description> MySQL源码解析 三次握手四次挥手详解 Http协议详解 网络基础和协议部分 分布式系统 Https与加密算法的运用  </description>
    </item>
    
    <item>
      <title>C&#43;&#43;面试题总结</title>
      <link>https://only0322.github.io/post/cpp/interview/</link>
      <pubDate>Sat, 26 Sep 2020 17:02:02 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/cpp/interview/</guid>
      <description>1.多态的实现 存在虚函数的类至少有一个(多继承会有多个)一维的虚函数表叫做虚表(virtual table)，属于类成员，虚表的元素值是虚函数的入口地址，在编译时就已经为其在数据端分配了空间。
编译器另外还为每个类的对象提供一个虚表指针(vptr)，指向虚表入口地址，属于对象成员。
在实例化派生类对象时，先实例化基类，将基类的虚表入口地址赋值给基类的虚表指针，当基类构造函数执行完时，再将派生类的虚表入口地址赋值给基类的虚表指针（派生类和基类此时共享一个虚表指针，并没有各自都生成一个），在执行父类的构造函数。
以上是C++多态的实现过程，可以得出结论：
 1.有虚函数的类必存在一个虚表。 2.虚表的构建：基类的虚表构建，先填上虚析构函数的入口地址，之后所有虚函数的入口地址按在类中声明顺序填入虚表；派生类的虚表构建，先将基类的虚表内容复制到派生类虚表中，如果派生类覆盖了基类的虚函数，则虚表中对应的虚函数入口地址也会被覆盖，为了后面寻址的一致性。  虚函数表中有序放置了父类和子类中的所有虚函数，并且相同虚函数在类继承链中的每一个虚函数表中的偏移量都是一致的。所以确定的虚函数对应virtual table中一个固定位置n，n是一个在编译时期就确定的常量，所以，使用vptr加上对应的n，就可以得到对应的函数入口地址。</description>
    </item>
    
    <item>
      <title>Node.js的垃圾回收机制</title>
      <link>https://only0322.github.io/post/node/gc/</link>
      <pubDate>Thu, 24 Sep 2020 16:24:21 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/node/gc/</guid>
      <description>垃圾回收算法 垃圾：无法再被访问的对象或内存空间。
延迟：指平均每次垃圾回收开始到结束需要的时间。
吞吐量：指平均一定时间内能回收多少内存，内存多少这个概念非常广泛，可以指多少个对象，也可以指多少字节的空间，具体的应该看指标应需求而异。
根节点：如全局变量上的对对象的引用、栈上对对象的引用等用户一定能够访问到的地址，是寻找活对象的入口。
1.引用计数 这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。我们可以为每个对象都增加一个计数器，来记录对这个对象的引用数量，当引用计数归零时，这个对象变成了垃圾。
优点：
 (1)内存释放及时，当一个对象死亡时其占用的内存马上被释放 (2)延迟低，内存释放的时间均匀地分布在各个时间段  缺点:</description>
    </item>
    
    <item>
      <title>Nodejs闭包</title>
      <link>https://only0322.github.io/post/node/bibao/</link>
      <pubDate>Wed, 23 Sep 2020 22:46:17 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/node/bibao/</guid>
      <description>简述 闭包是js的一个难点也是它的一个特色，是我们必须掌握的js高级特性，那么什么是闭包呢？它又有什么用呢？
我们都知道，js的作用域分两种，全局和局部，基于我们所熟悉的作用域链相关知识，我们知道在js作用域环境中访问变量的权利是由内向外的，内部作用域可以获得当前作用域下的变量并且可以获得当前包含当前作用域的外层作用域下的变量，反之则不能，也就是说在外层作用域下无法获取内层作用域下的变量，同样在不同的函数作用域中也是不能相互访问彼此变量的，那么我们想在一个函数内部也有限权访问另一个函数内部的变量该怎么办呢？闭包就是用来解决这一需求的，闭包的本质就是在一个函数内部创建另一个函数。
我们首先知道闭包有3个特性：
①函数嵌套函数
②函数内部可以引用函数外部的参数和变量
③参数和变量不会被垃圾回收机制回收
function a() { var i = 0; function b() { alert(++i); } return b; } var c = a(); c(); 这段代码有两个特点：</description>
    </item>
    
    <item>
      <title>位运算总结</title>
      <link>https://only0322.github.io/post/leetcode/binary/</link>
      <pubDate>Fri, 11 Sep 2020 17:05:36 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/leetcode/binary/</guid>
      <description>求出反码中2的个数 class Solution { public: int NumberOf1(int n) { unsigned int m = n; int count = 0; while(m) { count += (m&amp;amp;1); m = m&amp;gt;&amp;gt;1; } return count; } }; unsigned 可以将int转换一下，有符号整数变为无符号数。</description>
    </item>
    
    <item>
      <title>链表部分</title>
      <link>https://only0322.github.io/post/leetcode/listcircle/</link>
      <pubDate>Fri, 11 Sep 2020 08:16:07 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/leetcode/listcircle/</guid>
      <description>判断链表是否有环 方法 快慢指针
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { ListNode * p1 = head, * p2 = head; while(p2 !</description>
    </item>
    
    <item>
      <title>数据结构与算法题汇总</title>
      <link>https://only0322.github.io/post/shuju/leetcodeall/</link>
      <pubDate>Fri, 11 Sep 2020 08:13:34 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/shuju/leetcodeall/</guid>
      <description>牛客网 1.链表部分 2.位运算部分</description>
    </item>
    
    <item>
      <title>Nodejs面试题汇总</title>
      <link>https://only0322.github.io/post/node/interview/</link>
      <pubDate>Thu, 10 Sep 2020 10:55:25 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/node/interview/</guid>
      <description>一、Nodejs模块引入方式 Node中，每个文件模块都是一个对象，它的定义如下：
function Module(id, parent) { this.id = id; this.exports = {}; this.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;多线程初探</title>
      <link>https://only0322.github.io/post/cpp/thread/</link>
      <pubDate>Wed, 09 Sep 2020 22:47:04 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/cpp/thread/</guid>
      <description>一、基本程序 #include &amp;lt;iostream&amp;gt;#include &amp;lt;thread&amp;gt;using namespace std; static const int threads = 10; void * co(void* args) { cout&amp;lt;&amp;lt;&amp;#34;test&amp;#34;&amp;lt;&amp;lt;endl; } int main() { pthread_t th[threads]; for(int i=0;i&amp;lt;threads;i++) { int res = pthread_create(&amp;amp;th[i],nullptr,co,nullptr); if(res !</description>
    </item>
    
    <item>
      <title>C&#43;&#43;虚函数总结</title>
      <link>https://only0322.github.io/post/cpp/virtual/</link>
      <pubDate>Wed, 09 Sep 2020 17:08:08 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/cpp/virtual/</guid>
      <description>一、虚函数的定义 虚函数是为了允许用基类的指针来调用子类的这个函数
二、简单实现 class Next :public Base { void show() { cout&amp;lt;&amp;lt;&amp;#34;Next show&amp;#34;&amp;lt;&amp;lt;endl; } }; class That :public Base { void show() override { cout&amp;lt;&amp;lt;&amp;#34;That show&amp;#34;&amp;lt;&amp;lt;endl; } }; class Same :public Base { virtual void show() { cout&amp;lt;&amp;lt;&amp;#34;That show&amp;#34;&amp;lt;&amp;lt;endl; } }; int main() { Base *be = new Next; be-&amp;gt;show(); return 0; } 这就实现了Base调用Next类的函数了。</description>
    </item>
    
    <item>
      <title>Go语言基础</title>
      <link>https://only0322.github.io/post/go/base/</link>
      <pubDate>Tue, 08 Sep 2020 06:12:45 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/go/base/</guid>
      <description>一、Hello World package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello, World!</description>
    </item>
    
    <item>
      <title>用Node.js实现一个Redis</title>
      <link>https://only0322.github.io/post/opensource/nodis/</link>
      <pubDate>Fri, 31 Jul 2020 18:59:54 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/opensource/nodis/</guid>
      <description>项目背景 利用Nodejs来实现一个Node存储服务(Node Dictionary Server)
源码 码云链接
用到的编程语言和环境 操作系统：Windows10/MacOS
语言：JavaScript
框架:Node</description>
    </item>
    
    <item>
      <title>哈希算法与哈希表详解</title>
      <link>https://only0322.github.io/post/shuju/hash/</link>
      <pubDate>Tue, 14 Jul 2020 22:06:23 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/shuju/hash/</guid>
      <description>一、什么是哈希函数 Hash（哈希），又称“散列”。
散列（hash）英文原意是“混杂”、“拼凑”、“重新表述”的意思。
在某种程度上，散列是与排序相反的一种操作，排序是将集合中的元素按照某种方式比如字典顺序排列在一起，而散列通过计算哈希值，打破元素之间原有的关系，使集合中的元素按照散列函数的分类进行排列。
在介绍一些集合时，我们总强调需要重写某个类的 equlas() 方法和 hashCode() 方法，确保唯一性。这里的 hashCode() 表示的是对当前对象的唯一标示。计算 hashCode 的过程就称作 哈希。</description>
    </item>
    
    <item>
      <title>Redis知识整理</title>
      <link>https://only0322.github.io/post/other/redis/</link>
      <pubDate>Mon, 13 Jul 2020 22:18:20 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/other/redis/</guid>
      <description>一、简介 redis(REmote DIctionary Server)是一个key-value存储系统，它由C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value类型的数据库，并提供多种语言的API。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）。
这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。
与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步，redis在3.0版本推出集群模式。
二、Redis的特点  k、v键值存储以及数据结构存储（如列表、字典） 所有数据(包括数据的存储)操作均在内存中完成 单线程服务(这意味着会有较多的阻塞情况)，采用epoll模型进行请求响应，对比nginx 支持主从复制模式，更提供高可用主从复制模式（哨兵） 去中心化分布式集群 丰富的编程接口支持，如Python、Golang、Java、php、Ruby、Lua、Node.</description>
    </item>
    
    <item>
      <title>Vue&#43;Electron环境搭建</title>
      <link>https://only0322.github.io/post/front/elevue/</link>
      <pubDate>Mon, 22 Jun 2020 20:54:59 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/front/elevue/</guid>
      <description>一、创建项目 vue init simulatedgreg/electron-vue
二、报错处理 先npm install
然后修改webpack.web.config.js：
new HtmlWebpackPlugin({ filename: &amp;#39;index.</description>
    </item>
    
    <item>
      <title>QTableWidget使用</title>
      <link>https://only0322.github.io/post/qt/tablewidget/</link>
      <pubDate>Sun, 21 Jun 2020 07:21:45 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/qt/tablewidget/</guid>
      <description>一、清空 初始化 ui-&amp;gt;tableWidget-&amp;gt;clearContents(); //先清空 初始化 ui-&amp;gt;tableWidget-&amp;gt;setRowCount(0); 二、表头 for(int i=0;i&amp;lt;detailArray.size();i++) { QJsonValue tableColoum = detailArray.</description>
    </item>
    
    <item>
      <title>QTreeView使用</title>
      <link>https://only0322.github.io/post/qt/treeview/</link>
      <pubDate>Sun, 21 Jun 2020 07:19:45 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/qt/treeview/</guid>
      <description>一、主要用法，增加元素 for(int i=0;i&amp;lt;array.size();i++) { QJsonValue value = array.at(i); QString project = value[&amp;#34;name&amp;#34;].</description>
    </item>
    
    <item>
      <title>QTableView的使用</title>
      <link>https://only0322.github.io/post/qt/tableview/</link>
      <pubDate>Sun, 21 Jun 2020 07:12:50 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/qt/tableview/</guid>
      <description>一、获取当前行 QModelIndex name = ParamModel-&amp;gt;index(i,0,QModelIndex()); QModelIndex value = ParamModel-&amp;gt;index(i,1,QModelIndex()); QString strName = name.</description>
    </item>
    
    <item>
      <title>用Qt制作一个Postman</title>
      <link>https://only0322.github.io/post/opensource/postman/</link>
      <pubDate>Fri, 19 Jun 2020 19:45:12 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/opensource/postman/</guid>
      <description>项目源码地址:码云
一、什么是postman？ 著名开源项目之一，主要作用是后端利用postman来调试自己开发的接口。通过post给服务器发送请求，模拟浏览器的行为。
二、MyPostman用到的技术  C++、Qt。 Qt的http框架，QJson，EasyQJson。 Sqlite3数据库  三、请求的收发  发请求  void MyPostman::RequestGET(QString BaseUrl) { QNetworkRequest request; int count = ui-&amp;gt;tableView_Params-&amp;gt;model()-&amp;gt;rowCount(); for(int i=0;i&amp;lt;count;i++) { QModelIndex name = ParamModel-&amp;gt;index(i,0,QModelIndex()); QModelIndex value = ParamModel-&amp;gt;index(i,1,QModelIndex()); QString strName = name.</description>
    </item>
    
    <item>
      <title>Rust编写的Web服务</title>
      <link>https://only0322.github.io/post/rust/webserver/</link>
      <pubDate>Sat, 13 Jun 2020 16:24:37 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rust/webserver/</guid>
      <description>一、最基本的Web服务器 先看代码：
use std::net::{TcpListener, TcpStream}; fn handle_client(_stream: TcpStream) { let mut buffer = [0; 512]; stream.</description>
    </item>
    
    <item>
      <title>Rust的进阶知识</title>
      <link>https://only0322.github.io/post/rust/rustsenior/</link>
      <pubDate>Sat, 13 Jun 2020 13:17:38 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rust/rustsenior/</guid>
      <description>一、Rust 组织管理 Rust 中有三个重要的组织概念：箱、包、模块。
1.箱 &amp;ldquo;箱&amp;quot;是二进制程序文件或者库文件，存在于&amp;quot;包&amp;quot;中。
&amp;ldquo;箱&amp;quot;是树状结构的，它的树根是编译器开始运行时编译的源文件所编译的程序。
2.包 当我们使用 Cargo 执行 new 命令创建 Rust 工程时，工程目录下会建立一个 Cargo.</description>
    </item>
    
    <item>
      <title>Rust的数据类型</title>
      <link>https://only0322.github.io/post/rust/types/</link>
      <pubDate>Sat, 13 Jun 2020 09:20:00 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rust/types/</guid>
      <description>一、整型 整数型简称整型，按照比特位长度和有无符号分为一下种类：
   位长度 有符号 无符号     8-bit i8 u8   16-bit i16 u16   32-bit i32 u32   64-bit i64 u64   128-bit i128 u128   arch isize usize    通过let mut a :xxx = [value]来使用，例如：</description>
    </item>
    
    <item>
      <title>Rust基础语法</title>
      <link>https://only0322.github.io/post/rust/rustbase/</link>
      <pubDate>Sat, 13 Jun 2020 07:38:43 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rust/rustbase/</guid>
      <description>一、变量 1. 可变与不可变 Rust的变量分可变变量和不可变变量。
let a = 1就是一个不可变变量。这一点对于写过C的程序员来说很难理解。但Rust此举其实是为了防止程序中的变量以一种不可控的方式更改了自身的值。
let mut a = 1,此时a就是一个可变变量了。</description>
    </item>
    
    <item>
      <title>Rust的安装与启动</title>
      <link>https://only0322.github.io/post/rust/ruststart/</link>
      <pubDate>Sat, 13 Jun 2020 07:02:38 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rust/ruststart/</guid>
      <description>安装 Rust的安装也分系统
Windows下为:
https://www.rust-lang.org/tools/install
MacOS:
curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.</description>
    </item>
    
    <item>
      <title>Rust知识合集</title>
      <link>https://only0322.github.io/post/rust/rustmain/</link>
      <pubDate>Fri, 12 Jun 2020 23:01:17 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rust/rustmain/</guid>
      <description>语法部分  Rust的安装与启动 Rust基本语法 Rust的数据类型 Rust的进阶知识  实战部分  Rust编写的Web服务  </description>
    </item>
    
    <item>
      <title>23种设计模式归纳</title>
      <link>https://only0322.github.io/post/other/pattern/</link>
      <pubDate>Thu, 11 Jun 2020 22:24:14 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/other/pattern/</guid>
      <description>设计模式的定义 软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。
开闭原则：鼓励扩展，但拒绝（或不推荐）修改。比如BFF中经常出现v2,v3的函数。
设计模式的分类 总体来说设计模式分为三大类：
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
一、单例模式 概念：</description>
    </item>
    
    <item>
      <title>常见正则表达式汇总</title>
      <link>https://only0322.github.io/post/other/regexp/</link>
      <pubDate>Tue, 09 Jun 2020 13:56:23 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/other/regexp/</guid>
      <description>数字校验 数字： ^[0-9]*$ n位的数字： ^\d{n}$ 至少n位的数字： ^\d{n,}$ m-n位的数字： ^\d{m,n}$ 零和非零开头的数字： ^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字： ^([1-9][0-9]*)+(\.</description>
    </item>
    
    <item>
      <title>常见排序算法总结</title>
      <link>https://only0322.github.io/post/shuju/sort/</link>
      <pubDate>Sun, 07 Jun 2020 20:54:53 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/shuju/sort/</guid>
      <description>前置知识 排序算法的种类： 基本知识  时间复杂度  一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。
最坏时间复杂度和平均时间复杂度  最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。</description>
    </item>
    
    <item>
      <title>MySQL的索引和SQL优化</title>
      <link>https://only0322.github.io/post/mysql/sqlindex/</link>
      <pubDate>Sun, 07 Jun 2020 20:13:46 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/mysql/sqlindex/</guid>
      <description>索引 1.索引的分类 （1）从数据结构角度 B+树索引、hash索引、FULLTEXT索引、R-tree树索引
（2） 从物理角度 聚族索引、非聚族索引
（3）从逻辑角度 主键索引 唯一索引 多列索引 单列索引</description>
    </item>
    
    <item>
      <title>各种知识合集</title>
      <link>https://only0322.github.io/other/</link>
      <pubDate>Sun, 07 Jun 2020 18:31:04 +0800</pubDate>
      
      <guid>https://only0322.github.io/other/</guid>
      <description> Rust学习 Go学习 wrk使用  </description>
    </item>
    
    <item>
      <title>大杂烩</title>
      <link>https://only0322.github.io/allin/</link>
      <pubDate>Sun, 07 Jun 2020 18:30:11 +0800</pubDate>
      
      <guid>https://only0322.github.io/allin/</guid>
      <description> 常用正则表达式汇总 23种设计模式 docker学习  其他  极客时间学习汇总  </description>
    </item>
    
    <item>
      <title>MySQL数据库设计思想</title>
      <link>https://only0322.github.io/post/mysql/dbdesign/</link>
      <pubDate>Sun, 07 Jun 2020 18:27:55 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/mysql/dbdesign/</guid>
      <description>一.数据库设计的目的 主要是为了减少数据冗余，避免数据维护异常，节省空间，高效访问。
二.数据库设计的思想 1.理论 a.范式的概念 第一范式： 数据表中所有字段都是单一属性，不可再分
第二范式： 在第一范式的基础上，数据表中不存在非关键字段对任意候选关键字段的部分函数依赖
注：部分函数依赖是指，存在组合关键字中的某一关键字决定非关键字的情况，所有的单关键字都符合第二范式</description>
    </item>
    
    <item>
      <title>哈希表与哈希索引</title>
      <link>https://only0322.github.io/post/mysql/hashmap/</link>
      <pubDate>Wed, 03 Jun 2020 20:44:56 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/mysql/hashmap/</guid>
      <description>哈希函数 所谓的哈希函数，就是根据这个函数和查找关键字key，可以直接确定查找值所在位置，而不需要一个个比较。
预先知道key所在的位置，直接找到数据，这样可以提升查找的效率。
hash函数就是根据key计算出应该存储地址的位置，而哈希表是基于哈希函数建立的一种查找表。
哈希函数构造举例 假设需要统计中国人口的年龄分布，以10为最小单元。今年是2018年，那么10岁以内的分布在2008-2018，20岁以内的分布在1998-2008……假设2018代表2018-2008直接的数据，那么关键字应该是2018，2008，1998……
那么可以构造哈希函数H（key）=（2018-key）/10=201-key/10
   index key 年龄 人数（假设数据)     0 2018 0-10 200W   1 2008 10-20 250W   2 1998 20-30 253W   3 1988 30-40 300W    哈希索引 哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</description>
    </item>
    
    <item>
      <title>InnoDB存储引擎相关知识</title>
      <link>https://only0322.github.io/post/mysql/innodb/</link>
      <pubDate>Wed, 03 Jun 2020 20:06:13 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/mysql/innodb/</guid>
      <description>简介 InnoDB存储引擎支持B+树索引，哈希索引，全文索引和空间索引。后两者很少用到，但B+索引和哈希索引就很常见了。
前置知识 B+树 B+树是一种平衡查找树，其中B并不是指二叉树（Binary），而是平衡（Balance）。
MySQL的B+树索引可分为聚焦索引和非聚焦索引。
B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。B+ 树通常用于数据库和操作系统的文件系统中。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+ 树元素自底向上插入。</description>
    </item>
    
    <item>
      <title>MySQL的代码结构</title>
      <link>https://only0322.github.io/post/mysql/mysqlsrc/</link>
      <pubDate>Wed, 03 Jun 2020 19:46:59 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/mysql/mysqlsrc/</guid>
      <description>代码结构简介 在阅读源码之前，我们首先要熟悉MySQL的项目结构。而MySQL由于项目过于庞大，开发人员众多，理解每个文件夹、模块的用途，也是一件非常重要的事。
以下是MySQL的项目路径：
  BUILD: 内含在各个平台、各种编译器下进行编译的脚本。如compile-pentium-debug表示在pentium架构上进行编译的脚本。
  Client: 客户端工具，如mysql, mysqladmin之类。</description>
    </item>
    
    <item>
      <title>MySQL源码解析合集</title>
      <link>https://only0322.github.io/post/mysql/mysql/</link>
      <pubDate>Wed, 03 Jun 2020 19:39:29 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/mysql/mysql/</guid>
      <description>源码部分  MySQL源码的目录结构 InnoDB存储引擎相关知识 哈希表与哈希索引  数据库应用部分  MySQL数据库设计思想 索引和SQL优化思路  </description>
    </item>
    
    <item>
      <title>RabbitMQ消息重发、死信处理</title>
      <link>https://only0322.github.io/post/rabbitmq/rmqdead/</link>
      <pubDate>Tue, 02 Jun 2020 22:01:18 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rabbitmq/rmqdead/</guid>
      <description>了解死信队列 从图中发现知：
生产者发送的消息会经由交换机传送到绑定的队列中，然后经由消费者接受消息，消息一旦被消费者消费后，就会移除队列中，表示整个流程的结束。
但是如果消息没有被消费成功（或者说消息变为了死信），那么正常来说和原来的（正常）队列绑定的消费者就无法消费消息，那么变为死信的消息怎么处理啦！
在正常的业务中，会针对这一部分进行特殊处理，可以考虑指定一个死信交换机，并绑定一个死信队列，当消息变成死信时，该消息就会被发送到该死信队列上，这样就方便我们查看消息失败的原因了。
换句话说就是 没有被消费的消息， 换个地方重新被消费。
整个流程可以表示成
生产者 &amp;ndash;&amp;gt; 消息 &amp;ndash;&amp;gt; 交换机 &amp;ndash;&amp;gt; 队列 &amp;ndash;&amp;gt; 变成死信 &amp;ndash;&amp;gt; DLX交换机 &amp;ndash;&amp;gt;队列 &amp;ndash;&amp;gt; 消费者</description>
    </item>
    
    <item>
      <title>RabbitMQ的消息机制</title>
      <link>https://only0322.github.io/post/rabbitmq/rmqipc/</link>
      <pubDate>Tue, 02 Jun 2020 21:25:32 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rabbitmq/rmqipc/</guid>
      <description>1.RabbitMQ发送消息 对于消息发送方来说：
生产者发送一条消息，正常情况下是通过交换机发送到队列中，再由消费者接受队列中消息，由消费者进行逻辑操作。
但是RabbitMQ在收到消息后，还需要有一段时间才能将消息存入磁盘之中。 并且也并不是为每条消息都做fsync的处理，可能仅仅保存到cache中而不是物理磁盘上。如果RabbitMQ broker正巧发生了崩溃，因为消息还没来得及保存磁盘，消息将会丢失。
2.如何确认消息的发送是否成功？  a. 消息发送确认  RabbitMQ底层是利用了AMQP协议进行消息传输，关于消费者和生产者的模型就不再赘述了。</description>
    </item>
    
    <item>
      <title>RabbitMQ的启动过程</title>
      <link>https://only0322.github.io/post/rabbitmq/rmqstart/</link>
      <pubDate>Mon, 01 Jun 2020 21:27:07 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rabbitmq/rmqstart/</guid>
      <description>RMQ的代码结构 RabbitMQ的代码都是存放在src目录下的，其中rabbit.erl就是整个程序的启动入口。
在程序启动的过程中，自动地启动相关的进程，检查RMQ的版本，检查网络情况，确定日志的路径。
据说RMQ的启动构建了一张有向无环图，启动了一大堆的进程，这一块也可以在src目录下查阅。
前期的准备知识  AMQP协议    AMQP协议的全称</description>
    </item>
    
    <item>
      <title>RabbitMQ源码详解合集</title>
      <link>https://only0322.github.io/post/rabbitmq/rabbitmq/</link>
      <pubDate>Sun, 31 May 2020 22:15:34 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/rabbitmq/rabbitmq/</guid>
      <description> RabbitMQ的启动过程 RabbitMQ的消息机制 RabbitMQ消息重发、死信处理  </description>
    </item>
    
    <item>
      <title>Axios发送请求的具体使用</title>
      <link>https://only0322.github.io/post/front/axios/</link>
      <pubDate>Sun, 31 May 2020 07:45:36 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/front/axios/</guid>
      <description>axios具体请求类型   axios.request(config)
  axios.get(url[, config])
  axios.</description>
    </item>
    
    <item>
      <title>Vue制作的学生管理系统</title>
      <link>https://only0322.github.io/post/front/vuestudent/</link>
      <pubDate>Tue, 26 May 2020 06:21:13 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/front/vuestudent/</guid>
      <description>首先给出项目地址：码云连接
前端存放在manager目录下，后端则是BackEnd目录。
一、用到的技术 1.前端:Vue+iview 2.后端:Node.js+Koa 3.数据库:MySQL 二、各模块功能实现 1.登录界面 登录界面通过前端渲染两个对话框，供用户输入账号密码，发送post请求至后端。
后端去数据库查询预先配置好的公私钥，通过RSA解密密文，与前端发送的密码明文进行匹配。</description>
    </item>
    
    <item>
      <title>Koa和Koa-router的具体使用</title>
      <link>https://only0322.github.io/post/node/koa/</link>
      <pubDate>Wed, 20 May 2020 06:17:31 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/node/koa/</guid>
      <description>通过Koa来创建Koa实例 const Koa = require(&amp;#39;koa&amp;#39;); const app = new Koa(); 路由配置 预先设置好路由和响应，以此来进行操作。</description>
    </item>
    
    <item>
      <title>Vue&#43;Vue-cli&#43;ElementUI实战</title>
      <link>https://only0322.github.io/post/front/pos/</link>
      <pubDate>Thu, 14 May 2020 21:25:25 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/front/pos/</guid>
      <description>用Vue和Element-ui做的点菜系统，一些基本的代码记录
图标库使用 &amp;lt;template&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;router-view/&amp;gt; &amp;lt;i class = &amp;#34;icon iconfont iconchild&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;br&amp;gt; &amp;lt;i class = &amp;#34;icon iconfont iconbrightness&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 侧边栏及样式 &amp;lt;template&amp;gt; &amp;lt;div class=&amp;#34;left-nav&amp;#34;&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;i class=&amp;#34;icon iconfont iconaddto&amp;#34; &amp;gt;&amp;lt;/i&amp;gt; &amp;lt;div&amp;gt;收银&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;i class=&amp;#34;icon iconfont icondelete&amp;#34; &amp;gt;&amp;lt;/i&amp;gt; &amp;lt;div&amp;gt;店铺&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;i class=&amp;#34;icon iconfont iconbrightness&amp;#34; &amp;gt;&amp;lt;/i&amp;gt; &amp;lt;div&amp;gt;商品&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;i class=&amp;#34;icon iconfont iconbluray&amp;#34; &amp;gt;&amp;lt;/i&amp;gt; &amp;lt;div&amp;gt;会员&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;i class=&amp;#34;icon iconfont iconbluetooth_link&amp;#34; &amp;gt;&amp;lt;/i&amp;gt; &amp;lt;div&amp;gt;统计&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;i class=&amp;#34;icon iconfont iconbluetooth_link&amp;#34; &amp;gt;&amp;lt;/i&amp;gt; &amp;lt;div&amp;gt;设置&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { } &amp;lt;/script&amp;gt; &amp;lt;style &amp;gt; .</description>
    </item>
    
    <item>
      <title>Vue基础知识</title>
      <link>https://only0322.github.io/post/front/vuebase/</link>
      <pubDate>Sun, 10 May 2020 07:30:48 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/front/vuebase/</guid>
      <description>Hello World &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    
    <item>
      <title>Vue文章链接</title>
      <link>https://only0322.github.io/post/front/vue/</link>
      <pubDate>Sun, 10 May 2020 07:30:02 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/front/vue/</guid>
      <description> Vue基础知识大杂烩  </description>
    </item>
    
    <item>
      <title>前端知识归档</title>
      <link>https://only0322.github.io/front/</link>
      <pubDate>Sun, 10 May 2020 07:29:02 +0800</pubDate>
      
      <guid>https://only0322.github.io/front/</guid>
      <description> Vue学习 Vue+Element实战 学生管理系统 axios具体使用 Vue电商管理系统 Vue+Electron环境搭建 electron打包  </description>
    </item>
    
    <item>
      <title>Anafich——报文解析工具</title>
      <link>https://only0322.github.io/post/opensource/anafich/</link>
      <pubDate>Wed, 29 Apr 2020 21:22:23 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/opensource/anafich/</guid>
      <description>项目背景 通过预先配置好报文或文件的格式，在项目中遇到需要人工解析的报文，可以通过AnaFich来实现。
源码 AnaFich
用到的编程语言和环境 操作系统：Windows10/MacOS
语言：C++/Qt
软件流程 1.创建项目 通过读取和写入Json文件，完成对项目的配置。之后每次使用软件都需要读取Json文件，获得目前的项目和报文格式的配置。</description>
    </item>
    
    <item>
      <title>用C&#43;&#43;实现一个二叉树</title>
      <link>https://only0322.github.io/post/shuju/binarytree/</link>
      <pubDate>Sat, 25 Apr 2020 06:20:47 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/shuju/binarytree/</guid>
      <description>什么是二叉树 在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。
二叉树的主要特点 查找较为方便，如果是左子树比节点小，右子树比节点大的这种方式，在查找的过程中其实就实现了一个”部分“的二分查找。这种二叉树只要不是偏二叉树的话，查找的效率会比线性表快很多。
二叉树不是线性表，因为它并不是线性结构，而是树形的。二叉树不能一次就遍历完整棵树，而是要通过递归的方式。
优点：搜索和排序效率极高 缺点：插入和删除略微麻烦，且实现起来比链表更难。
源码</description>
    </item>
    
    <item>
      <title>Qt学习归档</title>
      <link>https://only0322.github.io/qt/</link>
      <pubDate>Fri, 24 Apr 2020 22:58:32 +0800</pubDate>
      
      <guid>https://only0322.github.io/qt/</guid>
      <description> Tableview使用 Tablewidget使用 Treeview使用  </description>
    </item>
    
    <item>
      <title>C&#43;&#43;循环链表总结</title>
      <link>https://only0322.github.io/post/shuju/cirlist/</link>
      <pubDate>Mon, 13 Apr 2020 18:37:12 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/shuju/cirlist/</guid>
      <description>循环链表的结构与特点 循环链表也分为单链循环和双链循环，和普通的链表相比，区别就是遍历到尾节点之后，next指针不是空指针，而又重新指向了head。
还是先给出源码
cpp循环链表
具体实现 1.类定义 class Node { public: int data; Node * next; }; class CirList { private: Node * head; }; 2.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;双向链表实现</title>
      <link>https://only0322.github.io/post/shuju/doublelist/</link>
      <pubDate>Fri, 10 Apr 2020 18:20:46 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/shuju/doublelist/</guid>
      <description>双向链表的原理与特点 双链表相比单链表而言，有头结点和尾节点，而每个数据节点也有前后两个节点指针。
源码地址 码云链接
具体实现及原理 1.类结构定义 class Node { public: int data; Node * last; Node * next; }; class DoubleNode { private: Node * head; //头结点  Node * tail; //尾节点 }; 定义了head和tail节点，以及每个数据节点的前后指针，最基本的双向链表。</description>
    </item>
    
    <item>
      <title>单链表原理与C&#43;&#43;实现</title>
      <link>https://only0322.github.io/post/shuju/nodelist/</link>
      <pubDate>Sun, 22 Mar 2020 15:42:43 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/shuju/nodelist/</guid>
      <description>单链表的特点与运用场景 单链表是线性表的一种，对比顺序存储来说，链表的链式存储，也存在一定的优缺点。
优点：适用于不确定元素的个数，以及需要频繁地进行增删元素，查找元素的情况。
缺点：实现难度较顺序表更高，存储密度更低（同样的内存空间，需要存放节点指针的地址和存储的内容）
单链表的数据结构 data域&amp;ndash;存放结点值的数据域 next域&amp;ndash;存放结点的直接后继的地址（位置）的指针域（链域）
也正因为如此，才方便了我们插入和删除数据。
源码
单链表各模块详解 1.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;位运算总结</title>
      <link>https://only0322.github.io/post/cpp/bit/</link>
      <pubDate>Wed, 18 Mar 2020 09:25:22 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/cpp/bit/</guid>
      <description>位运算是什么？ 程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。
实际运用 1.找出数组中只出现过一次的数 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
题目的关键点是，其他数都出现了两次，这时可以想到异或的妙用。
a^a = 0; a^0 = a; a^b^a = a^a^b = 0^b = b; 通过前两条特性，以及最后的异或交换律，我们只需要将数组的每个元素依次异或，最后的结果就是只出现一次的那个数了。</description>
    </item>
    
    <item>
      <title>动态规划总结与实战</title>
      <link>https://only0322.github.io/post/shuju/dp/</link>
      <pubDate>Wed, 11 Mar 2020 22:33:19 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/shuju/dp/</guid>
      <description>什么是动态规划？ 动态规划（Dynamic Programming)是多将阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解的算法。
适用条件 任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性。
动态规划的运用  爬楼梯问题  假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 我们可以找出其中的规律：</description>
    </item>
    
    <item>
      <title>用C&#43;&#43;实现数组的自动扩容</title>
      <link>https://only0322.github.io/post/cpp/arrayautoadd/</link>
      <pubDate>Sat, 07 Mar 2020 20:32:27 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/cpp/arrayautoadd/</guid>
      <description>用到的技巧 其实就是指针的简单使用，能够通过练习，加深对指针的理解。而在C++容器中，vector也是用数组实现的自动扩容。
当然，我们需要保证数组名不会随之改变，不然就不算什么自动扩容了。
代码部分  动态数组的创建。  假设数组的长度是未知的，完全可以用new在堆区分配内存。
int *p =new int[len];</description>
    </item>
    
    <item>
      <title>Nodejs数据库和文件操作总结</title>
      <link>https://only0322.github.io/post/node/nodedb/</link>
      <pubDate>Thu, 05 Mar 2020 19:48:53 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/node/nodedb/</guid>
      <description>文件操作 需要引入nodejs自带的fs模块
var fs=require(&amp;quot;fs&amp;quot;); var path=require(&amp;quot;path&amp;quot;); 异步读取文件fs.readFileSync()
对buffer进行切割：slice()
buffer转为方便操作的字符串toString()
还需要进制转换操作</description>
    </item>
    
    <item>
      <title>nodejs16进制转2进制遇到的坑</title>
      <link>https://only0322.github.io/post/node/hextobin/</link>
      <pubDate>Tue, 03 Mar 2020 21:26:15 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/node/hextobin/</guid>
      <description>背景 我在初学nodejs这门语言的时候，遇到了16进制无法正常转成2进制的问题。
解决思路 先是对一个字符串使用toString(2)。然而发现字符串再使用这种方法，已经没有意义了。
16进制转2进制的过程：16进制字符串-&amp;gt;数字-&amp;gt;2进制数
weekdatebin=weekdate.slice(0,8); weekdatebin=parseInt(weekdatebin,&amp;quot;16&amp;quot;).toString(2); weekdatebin=PrefixInteger(weekdatebin,32); 但也有问题，24个十六进制数，是无法转成24*4的2进制数的，太长了，会报错。
一种解决方案，就是将这24位的数拆分成3个8位进行处理，还有一种方式则是通过C语言的按位与思想，但是没有深入尝试了。</description>
    </item>
    
    <item>
      <title>node.js学习归档</title>
      <link>https://only0322.github.io/nodejs/</link>
      <pubDate>Tue, 03 Mar 2020 21:25:15 +0800</pubDate>
      
      <guid>https://only0322.github.io/nodejs/</guid>
      <description> nodejs2进制转16进制 koa库的具体使用 Nodejs连接数据库、读取文件 Nodejs面试大方向总结 Nodejs闭包 Nodejs的垃圾回收 Nodejs按行读文件的简便方法n-readlines  </description>
    </item>
    
    <item>
      <title>著名压测工具webbench源码解析</title>
      <link>https://only0322.github.io/post/opensource/webbench/</link>
      <pubDate>Thu, 27 Feb 2020 16:33:28 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/opensource/webbench/</guid>
      <description>项目概述 Webbench是用的标准C语言编写，仅仅只有500多行代码的轻量级压测软件。
用到的技术有：Linux提供的运行时参数解析，多进程，服务器通信，管道。 github地址：wenbbench
项目整体流程 1.解析程序运行时的参数。
2.根据选择的http协议组装报文。
3.开始压力测试。
4.获取压力测试的结果。
1.解析程序运行时的参数 其实这就是传说中的argc argv[]，不过程序在此处用到了C语言的getopt_long函数。</description>
    </item>
    
    <item>
      <title>数据结构和算法文章归档</title>
      <link>https://only0322.github.io/shuju/</link>
      <pubDate>Wed, 26 Feb 2020 10:30:09 +0800</pubDate>
      
      <guid>https://only0322.github.io/shuju/</guid>
      <description>数据结构  单链表 双向链表 循环链表 二叉搜索树  算法  动态规划 常见排序算法总结 哈希算法与哈希表  刷题  数据结构与算法题汇总  </description>
    </item>
    
    <item>
      <title>开源项目文章归档</title>
      <link>https://only0322.github.io/opensource/</link>
      <pubDate>Wed, 26 Feb 2020 10:28:35 +0800</pubDate>
      
      <guid>https://only0322.github.io/opensource/</guid>
      <description>别人的  webbench源码详细解析 RabbitMQ源码解析合集 MySQL源码解析 Redis学习  自己的  AnaFich——报文解析工具 MyPostman——属于我自己的postman Nodis——Node存储服务  </description>
    </item>
    
    <item>
      <title>C/C&#43;&#43;文章归档</title>
      <link>https://only0322.github.io/cpp/</link>
      <pubDate>Wed, 26 Feb 2020 10:28:24 +0800</pubDate>
      
      <guid>https://only0322.github.io/cpp/</guid>
      <description> C++实现tcp通信 用C++实现数组的自动扩容 C++虚函数 C++多线程 C++面试题总结  </description>
    </item>
    
    <item>
      <title>Linux和macOS文章归档</title>
      <link>https://only0322.github.io/linux/</link>
      <pubDate>Wed, 26 Feb 2020 10:28:17 +0800</pubDate>
      
      <guid>https://only0322.github.io/linux/</guid>
      <description> macOS配置环境变量与Linux的不同点 shell实现git项目自动更新 如何在github高效地搜索项目 github下载加速 用hugo搭建个人博客  </description>
    </item>
    
    <item>
      <title>C&#43;&#43; socket初探</title>
      <link>https://only0322.github.io/post/cpp/socketlearn/</link>
      <pubDate>Tue, 25 Feb 2020 09:54:15 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/cpp/socketlearn/</guid>
      <description>本文讲述socket客户端和服务端的简单实现。
客户端  用到的头文件及用法  #include &amp;lt;iostream&amp;gt;/*获取设置socket，bind*/ #include&amp;lt;sys/socket.h&amp;gt;/*基本数据类型，如time_t*/ #include&amp;lt;sys/types.h&amp;gt;/*用于socketaddr_in结构体，htons系统调用*/ #include&amp;lt;netinet/in.h&amp;gt;/*对read write提供支持*/ #include&amp;lt;unistd.</description>
    </item>
    
    <item>
      <title>解决github下载速度慢的难题</title>
      <link>https://only0322.github.io/post/linux/gitfast/</link>
      <pubDate>Sun, 23 Feb 2020 19:32:42 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/linux/gitfast/</guid>
      <description>修改host文件  找到hosts文件  在macOS环境下，host文件位于 /etc/hosts
通过sudu vim /etc/hosts来修改文件
 查找github使用的动态IP</description>
    </item>
    
    <item>
      <title>如何在github高效地搜索开源项目</title>
      <link>https://only0322.github.io/post/linux/gitsearch/</link>
      <pubDate>Sun, 23 Feb 2020 15:55:50 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/linux/gitsearch/</guid>
      <description>概述 本文讲述如何在github的搜索栏找到自己想要的项目。
重点无非如下：
  项目名
  项目概述
  star数</description>
    </item>
    
    <item>
      <title>用shell脚本实现git项目自动（定时）更新</title>
      <link>https://only0322.github.io/post/linux/gitauto/</link>
      <pubDate>Sun, 23 Feb 2020 09:16:05 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/linux/gitauto/</guid>
      <description>背景 我在学习开源项目的过程中，会囤积不少的开源项目，因此也就需要用一个便捷的脚本进行管理，对开源项目进行自动同步。
环境设置 macOS或者Linux都可以，通过shell脚本实现
脚本 #/bin/bash Opensource=/Users/hideyoshi/Desktop/OpenSource #切换到开源项目根目录 cd ${Opensource} currentpath=$(pwd) echo &amp;#34;currentpath is :$currentpath&amp;#34; rm -f /Users/hideyoshi/Desktop/shbin/filelist.</description>
    </item>
    
    <item>
      <title>macOS配置环境变量与Linux的不同点</title>
      <link>https://only0322.github.io/post/linux/bash/</link>
      <pubDate>Sat, 22 Feb 2020 21:44:19 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/linux/bash/</guid>
      <description>前因后果 在Linux中，用户的环境变量由根目录的.bash_profile管理。事实上macOS也该是如此的，但我这么设置了之后，却发现每次都需要重新source，环境变量才能正常工作。
原因 其实也很简单，在同级目录下的.zshrc，是新版macOS更换bash到zsh之后，真正的配置文件。
因此，每次用户登录的时候，调用的不是.bash_profile，而是.zshrc了。
解决方案 可以考虑在.zshrc里source我们的配置文件，这样与在Linux的习惯一致。当然也可以直接在.zshrc编写环境变量。
问题到这里，也算是解决了。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; static用法总结</title>
      <link>https://only0322.github.io/post/cpp/static/</link>
      <pubDate>Thu, 20 Feb 2020 23:35:34 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/cpp/static/</guid>
      <description>要点总结   全局静态变量
在全局变量前加上关键字static，全局变量就定义成一个全局静态变量. 静态存储区，在整个程序运行期间一直存在。 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）； 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
   局部静态变量</description>
    </item>
    
    <item>
      <title>搭建hugo博客的详细方法</title>
      <link>https://only0322.github.io/post/linux/blog/</link>
      <pubDate>Thu, 20 Feb 2020 10:38:41 +0800</pubDate>
      
      <guid>https://only0322.github.io/post/linux/blog/</guid>
      <description>主要步骤如下
 安装hugo 配置github 发布  hugo安装 其实还是非常曲折的过程，原本官方都是推荐用brew install hugo的方式来进行安装，然而国内的网络环境实在是非常不方便。</description>
    </item>
    
    <item>
      <title>Java文章归档</title>
      <link>https://only0322.github.io/java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://only0322.github.io/java/</guid>
      <description> Java思维导图合集
  hashmap知识归纳
  jvm归纳
  </description>
    </item>
    
  </channel>
</rss>
